# パーソナル AI デイリーブリーフィング Agent — アプリケーション仕様書

> **ステータス**: Draft v0.4  
> **最終更新**: 2026-02-24

---

## 1. 概要

指定フォルダ配下の Markdown ファイル群を定期的に読み込み、GitHub Copilot SDK を用いて最新情報の取得・要約を行い、結果を Markdown ファイルとして出力する **Windows 専用**クライアントデスクトップアプリケーション。  
ファイル出力時にはデスクトップ上で通知を提示し、ユーザーが即座に確認できるようにする。  
OS のスケジューラ（Task Scheduler 等）には依存せず、アプリ内で定期実行を完結させる。

---

## 2. 技術スタック

| 項目 | 技術 / ツール |
|---|---|
| 対象 OS | **Windows 10 / 11** |
| 言語 | Python 3.12+ |
| AI SDK | GitHub Copilot SDK (`github-copilot-sdk`) |
| デスクトップ UI | `pystray`（システムトレイ常駐・メニュー） + `winotify`（トースト通知） |
| MD プレビューア | `tkinter` + `tkinterweb`（HTML/CSS レンダリング） + `markdown2`（MD→HTML 変換） |
| クイズ回答 UI | **ネイティブ tkinter ウィジェット**（Radiobutton / Text / Button）— `tkinterweb` は JS 非対応のため HTML フォームではなくネイティブ UI で実装 |
| 定期実行 | **アプリ内蔵スケジューラ**（`APScheduler` を採用） — OS スケジューラ不使用 |
| 社内情報検索 | **WorkIQ MCP サーバー**（**stdio** MCP プロトコル経由で社内ナレッジを検索、`npx -y @microsoft/workiq mcp` で自動起動） |
| パッケージ管理 | `uv` + `pyproject.toml` |

### 2.1 GitHub Copilot SDK 利用パターン

| 項目 | 設定値・方針 |
|---|---|
| モデル | `claude-sonnet-4.6`（`config.yaml` で変更可） |
| システムメッセージ | `mode: "replace"`（独自プロンプトで完全置換、SDK 標準ガードレールは使わない） |
| ストリーミング | 無効（ファイル出力用バッチ処理のため不要） |
| レスポンス取得 | `session.send_and_wait()` を使用（手動イベントハンドリング不要） |
| Infinite Sessions | 無効（各ブリーフィングは独立した1回限りのセッション） |
| Reasoning Effort | `medium`（`config.yaml` で変更可） |
| MCP サーバー | `create_session(mcp_servers=...)` で WorkIQ MCP を **stdio MCP** として登録。`npx -y @microsoft/workiq mcp` コマンドで自動起動する。`config.yaml` の `workiq_mcp.enabled` で有効/無効を切り替え（URL 設定は不要） |
| async ブリッジ | APScheduler の同期ジョブから `asyncio.run()` で SDK の async API を呼び出す |
| SDK リファレンス | [Python README](https://github.com/github/copilot-sdk/blob/main/python/README.md)、[Getting Started](https://github.com/github/copilot-sdk/blob/main/docs/getting-started.md)、[MCP Overview](https://github.com/github/copilot-sdk/blob/main/docs/mcp/overview.md) |

---

## 3. 機能一覧

### 3.1 定期実行（アプリ内蔵スケジューラ）

- **アプリプロセス内で `APScheduler` を使用**し、指定間隔で主処理メソッドを自動起動する。
- OS のタスクスケジューラ（Windows Task Scheduler）や cron には依存しない。アプリ単体で定期実行を完結させる。
- アプリ起動時にスケジューラを開始し、アプリ終了時にスケジューラを停止する。
- 実行スケジュールは設定ファイル（`config.yaml`）で管理する。
- **スケジュールは機能ごとに独立して設定可能**:
  - **機能 A（最新情報の取得）** と **機能 B（復習・クイズ）** にそれぞれ別の cron スケジュールを設定できる。
  - APScheduler には機能ごとに個別のジョブを登録する（`job_a`, `job_b`）。
  - **同時刻に A と B が重なった場合**: A+B を統合実行はせず、**B の実行を自動的に 3 分遅延** して順次実行する。これにより SDK 呼び出しは常に機能単位（A または B）となり、プロンプトをシンプルに保つ。また、通知が短時間に連続する煩わしさも軽減される。
    - 避譲ロジック: ジョブ発火時に `job_a` が実行中であれば `job_b` を 3 分後にリスケジュール（その逆も同様）。
  - **A のみまたは B のみが発火した場合**: 該当機能のみを含むプロンプトで SDK を呼び出す。
- **スケジュールは cron 形式（APScheduler の `CronTrigger`）で柔軟に指定可能**。時間単位は「時」単位以上とする。
  - 例: A は「毎日 9:00」、B は「月・水・金の 8:00」など
- **システムトレイメニューの「設定」から GUI で機能ごとのスケジュールを変更可能**とする。変更内容は `config.yaml` に書き込まれ、スケジューラに即時反映する。
- システムトレイメニューからの手動実行（オンデマンド）も可能とする。
  - 手動実行メニューは「☐ 最新情報（A）」「☐ 復習・クイズ（B）」のチェックボックス付きで、実行する機能を選択可能（デフォルトは両方 ON）。

### 3.2 フォルダ読み込み

- 設定ファイル（または設定メニュー GUI）で指定された親フォルダを起点に、配下を再帰的に走査する。
- **読み込み対象フォルダは親フォルダのみを指定**する。配下のサブフォルダは個別に指定せず、自動的に再帰走査される。
- **読み込み対象フォルダは設定メニューから GUI で追加・削除・変更が可能**。フォルダ選択ダイアログで指定し、`config.yaml` に反映する。
- 対象ファイル: `.md`（Markdown）ファイル。
- frontmatter（YAML ヘッダー）からメタデータ（`priority`, `deadline`, `tags` 等）を抽出する。

### 3.3 Copilot SDK 連携（ブリーフィング生成）

- フォルダ配下の MD ファイル群をコンテキストとして GitHub Copilot SDK に渡し、以下の **2つの機能** でブリーフィングを生成する。
- SDK の LLM 推論（判断ループ）を用いて「今、このユーザーに届けるべき情報は何か？」を自律的に判断する。
- **実行対象の機能（A のみ / B のみ）はスケジューラのトリガーまたは手動実行時の選択に応じて決定** される。対応するシステムプロンプトが自動選択される（プロンプト設計 参照）。
- A と B は常に個別の SDK 呼び出しとして実行される（統合実行はしない）。スケジュール重複時は 3 分遅延で順次実行される（3.1 参照）。

#### ファイル選定戦略（関心度スコアリング + ディスカバリー機構）

フォルダ内のファイルは多岐にわたるため、**アプリ側でプレフィルタ**してから LLM に渡す方式を採用する。

##### 利用するシグナル

| # | シグナル | 取得方法 | 意味 |
|---|---|---|---|
| S1 | **ファイル更新日時** | `os.path.getmtime()` | 最近触ったファイル ＝ 今アクティブに取り組んでいる |
| S2 | **ファイル作成日時** | `os.path.getctime()` | 新しく作ったファイル ＝ 最近興味を持ち始めた |
| S3 | **frontmatter `priority`** | YAML パース | ユーザーが明示的に重要と設定したもの |
| S4 | **frontmatter `deadline`** | YAML パース | 期限が近いもの ＝ 今やるべきもの |
| S5 | **frontmatter `tags`** | YAML パース | トピック分類の手がかり |
| S6 | **チェックボックス未完了率** | `- [ ]` カウント | 未完了が多い ＝ まだ作業中 |
| S7 | **ファイル内容そのもの** | ファイル読み込み | トピック・キーワードの判定 |
| S8 | **フォルダ構造・名前** | パス解析 | カテゴリ分けの手がかり（`learning/`, `projects/` 等） |

##### 関心度スコアリング

各ファイルに以下のロジックでスコアを算出し、上位ファイルを優先的に LLM に渡す:

| シグナル | 条件 | スコア |
|---|---|---|
| 更新日時 (S1) | 今日・昨日 | +50 |
| | 1週間以内 | +30 |
| | 1ヶ月以内 | +10 |
| priority (S3) | `high` | +30 |
| | `medium` | +15 |
| deadline (S4) | 3日以内 | +25 |
| | 7日以内 | +15 |
| 未完了チェックボックス (S6) | 1つ以上あり | +10 |

- frontmatter がないファイルは更新日時ベースのスコアのみで評価する（フォールバック）。

##### ハイブリッド選定（通常回 + ディスカバリー回）

LLM に渡す最大ファイル数を **20件** とし、每回の実行を「通常回」と「ディスカバリー回」に分ける:

| 回種 | 頻度 | スコア上位枚 | ランダム枚 | 目的 |
|---|---|---|---|---|
| **通常回** | N-1回 / N回 | 17件 | 3件 | 関心の高いファイル中心 + 軽いランダム性 |
| **ディスカバリー回** | 1回 / N回 | 5件 | 15件 | 普段見ないファイルを探索、忘れていたトピックを再発見 |

- `N`（ディスカバリー間隔）のデフォルトは **5**。`config.yaml` の `discovery_interval` で変更可能（GUI 設定はなし）。
- ディスカバリー回の判定: `run_count_a % discovery_interval == 0`（A の場合）/ `run_count_b % discovery_interval == 0`（B の場合）。A と B で独立にカウントする

##### ランダム抽出ルール

| ルール | 内容 |
|---|---|
| **重み付け** | 最終更新が古いほどランダム抽出の重みが高い（`random.choices(weights=...)`）。未更新 30日以上のファイルを優先 |
| **重複抑止** | 直近3回でランダム選出されたファイルは除外（`state.json` の履歴を参照） |
| **プロンプト追記** | ディスカバリー回はシステムプロンプトに「今回はディスカバリー回です。普段見ていないファイルが含まれています。新しい発見や忘れていたトピックを優先的に取り上げてください」と追記 |

##### 内部状態ファイル（state.json）

アプリディレクトリ直下に `state.json` を配置し、実行状態を永続化する:

```json
{
  "run_count_a": 25,
  "run_count_b": 17,
  "random_pick_history": [
    "learning/old-topic.md",
    "projects/archived/plan.md"
  ],
  "last_run_at": "2026-02-22T09:00:00",
  "output_folder_path": "C:\\Users\\user\\docs\\_briefings"
}
```

- `run_count_a` / `run_count_b`: 機能ごとの実行カウンタ（ディスカバリー回の判定に使用）。A と B で独立にカウントし、`run_count_a % discovery_interval == 0` で A のディスカバリー回を判定（B も同様）
- `random_pick_history`: 直近3回分のランダム選出ファイル（重複抑止用）
- `last_run_at`: 最終実行日時
- `output_folder_path`: 確定済みの出力フォルダのフルパス（3.4 参照）

#### 機能 A: 最新情報の取得（Web + 社内）

- フォルダ内の MD ファイルからトピック・キーワードを抽出し、関連する **最新情報** を取得する。
- 情報ソースは以下の2系統があり、**LLM が自律的にトピックに応じて使い分ける**（ツールルーティング）:
  - **Web 検索（Bing）**: 技術名・製品名・OSS の最新ニュース・ブログ・リリースノート等。SDK 組み込み機能に委譲。アプリ側で検索ライブラリや API キーは不要。
  - **社内検索（WorkIQ MCP）**: 社内プロジェクト・顧客・チームに関する社内ナレッジ（SharePoint, Teams 等）。**stdio MCP** プロトコル経由。`config.yaml` の `workiq_mcp.enabled: true` で有効化する（URL 設定は不要、`npx -y @microsoft/workiq mcp` で自動起動）。
- Copilot SDK の `create_session()` で `mcp_servers` パラメータに WorkIQ MCP を **stdio タイプ** で登録し、**1回の SDK 呼び出しで LLM が自律的にどちらを使うか（または両方使うか）判断** する。
- 取得した情報はソース（Web / 社内）を問わず LLM が要約し、**ソース URL 付き** でまとめて提供する。
- システムプロンプトにルーティングルールを明記して精度を担保する（プロンプト設計のセクション参照）。
- 例:
  - 学習ノートに「Azure Kubernetes Service」がある → Web 検索で AKS の最新アップデートを取得
  - タスクに「Terraform 移行」がある → Web 検索で Terraform の最新リリースノートを取得
  - 学習ノートに「Copilot SDK」がある → WorkIQ MCP で社内の関連ナレッジを取得 + Web 検索で公式ドキュメントを取得
  - プロジェクトノートに「顧客A向け提案」がある → WorkIQ MCP で社内事例・テンプレートを検索

##### WorkIQ MCP が未設定の場合の動作

- WorkIQ MCP の有効/無効は `config.yaml` の `workiq_mcp.enabled` で管理する。stdio 方式のため URL 設定は不要（`npx` が利用可能であれば動作する）。
- システムプロンプトには**常に WorkIQ MCP のツール使い分けルールを含める**。LLM が社内検索の必要性を判断し、必要に応じてツール呼び出しを試みる。
- **未設定（`enabled: false`）の場合**:
  1. アプリは **Web 検索のみで動作** する（SDK の `create_session()` で `mcp_servers` を登録しない）。
  2. システムプロンプトからも社内検索のルーティングルールを除外する（不要なツール参照を避けるため）。
  3. **初回起動時** および **5回に1回の頻度**（`config.yaml` で変更可）でトースト通知を表示:
     - タイトル: 「💡 社内情報検索を有効にしませんか？」
     - 本文: 「WorkIQ MCP を設定すると、社内ナレッジも検索対象に含まれます」
     - クリック時の動作: セットアップガイドダイアログを開く
  4. 通知から開くセットアップガイドダイアログ:
     - WorkIQ MCP の概要説明（stdio 方式で自動起動される旨、npx が必要な旨）
     - 「WorkIQ MCP を有効にする」チェックボックス
     - 「後で設定する」ボタン（ダイアログを閉じる）
     - 「今後表示しない」チェックボックス（`config.yaml` の `workiq_mcp.suppress_setup_prompt` を `true` に設定）
  5. `suppress_setup_prompt: true` で通知を完全非表示

#### 機能 B: 復習・クイズ生成

- フォルダ内の学習ノートを分析し、**知識定着を促す振り返りコンテンツ** を生成する。
- ノートの最終更新日に応じて **2つのパターン** に分類し、それぞれ異なるアプローチで出題する。
- frontmatter の `tags` や内容から学習トピックを自動判定する。

##### パターン①: 学習中のトピック（最終更新 1〜2週間以内）

- **目的**: 「正しく理解できているか？」の確認・定着
- **要点リマインド**: クイズの前に「💡 要点リマインド」として学習内容の要点を提示し、理解を整理してから出題する
- **出題数**: 2問
- **出題形式**:
  - **Q1（4択）**: 実践的な理解力を問う選択問題
  - **Q2（記述）**: 具体的なシナリオや概念について自分の言葉で説明させる問題
- **出題スタイル**（用語の定義を問う問題は避け、実践的な理解力を問う）:
  - 比較・使い分け問題（「A と B のどちらを選ぶべきか？」）
  - 応用シナリオ問題（「この要件の場合、どのアーキテクチャを採用すべきか？」）
  - トラブルシューティング問題（「このエラーの原因として最も可能性が高いのは？」）
  - メリット・デメリットの判断問題（「この方式の欠点は？」）
- **難易度**: やや高め
- **出力ラベル**: 📘
- 例:
  - 「💡 要点リマインド: Azure Functions には Consumption・Premium・Dedicated の3つのホスティングプランがあり、コスト・スケール・コールドスタートの特性が異なります」
  - → Q1:「Consumption プランと Premium プランの最も大きな違いは？ A) ... B) ... C) ... D) ...」
  - → Q2:「あなたのチームが低コストかつコールドスタート許容のワークロードを設計する場合、どのプランを選びその理由を説明してください」

##### パターン②: 長期未更新のトピック（最終更新 1ヶ月以上）

- **目的**: 「まだ覚えているか？」の確認・忘却防止・記憶の呼び戻し
- **出題数**: 2問
- **出題形式**:
  - **Q1（4択）**: 実務での判断を問う選択問題
  - **Q2（記述）**: 学んだ内容を自分の言葉で説明・整理させる問題
- **出題スタイル**（用語の定義を問う問題は避け、実践的な理解力を問う）:
  - 具体的なユースケースに基づく選択問題（「この要件ならどれを使う？」）
  - 個別概念の関係性を問う問題（「A を使うと B にどう影響する？」）
  - 実務での判断を問う問題（「この状況で最初に確認すべきことは？」）
- **難易度**: 基本〜中程度
- **出力ラベル**: 📗
- **要点リマインド**: クイズの前に「💡 要点リマインド」として学習内容の要約を提示し、思い出しを促してから出題する
- 例:
  - 「💡 要点リマインド: 1ヶ月前に学んだハイブリッド接続の要点は、ExpressRoute（専用線・高帯域）と VPN Gateway（暗号化トンネル・低コスト）の使い分けでした」
  - → Q1:「ExpressRoute のメリットとして正しくないものは？ A) ... B) ... C) ... D) ...」
  - → Q2:「VPN Gateway と ExpressRoute の使い分けの判断基準を簡潔に説明してください」

##### 出力形式（共通）

- **1回の実行で出題するトピックは 1 つだけ**（Q1 + Q2 の計2問）。
  - `run_count_b` の偶奇で📘学習中と📗振り返りを**交互に出題**する：
    - 奇数回: 📘 学習中のトピック（最終更新 1〜2週間以内）
    - 偶数回: 📗 振り返りトピック（最終更新 1ヶ月以上）
  - 対象ノートがない場合は、もう一方のパターンから出題する。
  - **Q1（4択）**: 選択肢 A〜D を提示する（正解・解説は含めない）
  - **Q2（記述）**: 具体的なシナリオや概念について説明を求める（模範解答は含めない）
- 正解・解説・模範解答は出力せず、ユーザーの回答後に **Copilot SDK で採点**（3.11 参照）
- **「○○とは何か？」のような用語定義を問う問題は出題しない**

#### プロンプト設計

実行対象の機能に応じて、システムプロンプトを **動的に切り替え** る。A と B は常に個別に実行されるため、プロンプトは A 用・ B 用の 2 パターンを用意する。

##### システムプロンプト: 機能 A（最新情報の取得）

```
あなたは「パーソナル AI デイリーブリーフィング Agent」です。
ユーザーのローカルフォルダにある Markdown ファイル群を分析し、
ノートに含まれるトピックについて最新のニュース・技術アップデート・
ブログ記事・社内ナレッジを取得し、要約してください。
必ずソース URL を付記してください。

## ツール使い分けルール
- **Web 検索（Bing）を使うべきケース**:
  - 技術名・製品名・OSS プロジェクト名に関する最新情報
  - 公式ドキュメント・ブログ・リリースノートの確認
  - 業界ニュース・トレンド
- **WorkIQ MCP を使うべきケース**:
  - 社内プロジェクト名・顧客名・チーム名が含まれるトピック
  - 社内事例・テンプレート・ナレッジ記事の検索
  - 社内アナウンス・ディスカッションの確認
- **判断に迷う場合**: 両方のツールで検索してください。
- **WorkIQ MCP で結果が見つからない場合**: そのセクションを省略してください。

## 出力ルール
- 出力は Markdown 形式で、日本語で記述してください。
- 各セクションに見出し（##）を付けてください。
- 情報がないセクションは省略してください（無理に埋めない）。
- ユーザーが朝の5分で読める分量を目安にしてください。
```

##### システムプロンプト: 機能 B（復習・クイズ）

```
あなたは「パーソナル AI デイリーブリーフィング Agent」です。
ユーザーのローカルフォルダにある Markdown ファイル群を分析し、
ノートの最終更新日を考慮して復習・クイズを生成してください。

- **📘 学習中のトピック**（最終更新 1〜2週間以内）:
  まず「💡 要点リマインド」として学習内容の要点を提示し、
  その後にクイズを2問出題。Q1 は4択、Q2 は記述式。
  応用シナリオやトラブルシューティングを含め、難易度はやや高め。
- **📗 振り返り**（最終更新 1ヶ月以上）:
  まず「💡 要点リマインド」として学習内容の要約を提示し、
  その後にクイズを2問出題。Q1 は4択、Q2 は記述式。
  難易度は基本〜中程度。
- 対象ノートがないパターンは省略してください。

## topic_key ルール
- 各トピックの見出し（### の行）の **直前** に、以下の形式で HTML コメントを挿入してください:
  `<!-- topic_key: {ソースファイルの相対パス}#{セクション識別子} -->`
- `{ソースファイルの相対パス}` はユーザープロンプトの「ファイル一覧」に記載されたパスをそのまま使用してください。
- `{セクション識別子}` はトピックを一意に識別できる短い英数字・ハイフンの文字列を付けてください（例: `hosting-plans`, `hybrid-connectivity`）。
- 例: `<!-- topic_key: learning/azure-functions.md#hosting-plans -->`

## 出力ルール
- 出力は Markdown 形式で、日本語で記述してください。
- 各セクションに見出し（##）を付けてください。
- 情報がないセクションは省略してください（無理に埋めない）。
- **Q1 の正解・解説、Q2 の模範解答は出力に含めないでください。**
  採点はユーザーの回答後に別途行います。
- ユーザーが朝の5分で読める分量を目安にしてください。
```

> **実装メモ**: システムプロンプトは共通部品（ツール使い分けルール・出力ルール等）を
> テンプレートとして持ち、実行対象の機能に応じて動的に組み立てる。
> A の場合はツール使い分けルールを含める。WorkIQ MCP が未設定の場合は社内検索ルールを除外する。
> B の場合はツール使い分けルールを省略する。

- **ユーザープロンプト**（実行時に動的生成。機能 A / B でテンプレートを分ける）:

##### ユーザープロンプト: 機能 A（最新情報の取得）

```
## 実行情報
- 現在日時: {current_datetime}
- 対象フォルダ: {input_folders}

## ファイル一覧と概要
{file_list_with_metadata}

## ファイル内容
{file_contents}

上記のローカルファイルの内容を踏まえて、今日のデイリーブリーフィングを
生成してください。
```

##### ユーザープロンプト: 機能 B（復習・クイズ）

```
## 実行情報
- 現在日時: {current_datetime}
- 対象フォルダ: {input_folders}

## ファイル一覧と概要
{file_list_with_metadata}

## ファイル内容
{file_contents}

## 間隔反復情報（クイズ出題の参考）
{quiz_schedule_info}

上記のローカルファイルの内容を踏まえて、今日の復習・クイズを
生成してください。期限到来トピックがあればそちらを優先してください。
```

- **変数の説明**:
  - `{current_datetime}`: 実行日時（`2026-02-22 09:00`）
  - `{input_folders}`: 走査対象のフォルダパス一覧
  - `{file_list_with_metadata}`: ファイルパス・最終更新日・frontmatter メタデータの一覧
  - `{file_contents}`: 各 MD ファイルの本文（トークン上限を考慮して切り詰め可）
  - `{quiz_schedule_info}`（B 専用）: `next_quiz_at <= today` のトピック一覧。トピック名・Level・前回結果を含む。該当トピックがない場合は「期限到来トピックなし」と表示。

- **Tool 定義**（Copilot SDK の Tool Calling で使用）:
  - Web 検索 — SDK 組み込みの Bing 検索を利用（アプリ側で定義不要）
  - WorkIQ MCP — `config.yaml` で `workiq_mcp.enabled: true` かつ `url` が設定されている場合、`create_session()` の `mcp_servers` パラメータで HTTP MCP サーバーとして登録する

> **注**: ローカル MD ファイルの内容はユーザープロンプトの `{file_contents}` としてアプリ側で事前に埋め込むため、LLM が呼び出す Tool としての `read_local_context()` は不要。

### 3.4 結果出力（Markdown ファイル生成）

- 取得・要約した情報を Markdown ファイルとして出力フォルダに書き出す。
- **出力先**: 最初に指定された入力フォルダの直下に `_briefings` フォルダを自動作成し、その中に出力する。
  - 例: 入力フォルダが `C:\Users\user\docs` の場合 → `C:\Users\user\docs\_briefings\`
  - `_briefings` フォルダ名が既に存在する場合（ユーザーが同名フォルダを別用途で使用中など）は、`_briefings_2`, `_briefings_3` … のように連番を付与して作成する。
  - **確定した出力フォルダのフルパスは `state.json` の `output_folder_path` に記録** する。次回起動時はこの値を参照し、フォルダ名の再判定を行わない。`output_folder_path` が未設定または参照先が存在しない場合のみ再判定する。
- **機能 A / B で別ファイルとして出力する**（A と B は常に独立実行のため）。

#### ファイル名規則

| 機能 | ファイル名パターン | 例 |
|------|-------------------|----|
| A: 最新情報 | `briefing_news_YYYY-MM-DD_HHmmss.md` | `briefing_news_2026-02-22_090000.md` |
| B: 復習・クイズ | `briefing_quiz_YYYY-MM-DD_HHmmss.md` | `briefing_quiz_2026-02-22_080000.md` |

#### 機能 A 出力内容

```markdown
# 📰 デイリーブリーフィング — 最新情報

> 生成日時: 2026-02-22 09:00 | 対象フォルダ: 3 | 対象ファイル: 47

## <トピック1のタイトル>

- 要約文 …
- 🔗 ソース: [タイトル](URL)

## <トピック2のタイトル>

- 要約文 …
- 🔗 ソース: [タイトル](URL)

…（トピック数は LLM が判断）
```

- 各トピックは関連するフォルダ内ファイルに基づいて LLM が自動分類・見出し命名する。
- 各トピックにソース URL を必ず付与する（Web 検索結果の場合）。社内情報（WorkIQ）の場合はソース名のみ表示。

#### 機能 B 出力内容

```markdown
# 📝 デイリーブリーフィング — 復習・クイズ

> 生成日時: 2026-02-22 08:00 | 対象フォルダ: 3 | 対象ファイル: 47

## 📘 学習中のトピック

<!-- topic_key: learning/azure-functions.md#hosting-plans -->
### Azure Functions ホスティングプラン

**💡 要点リマインド**
- ポイント1 …
- ポイント2 …

**Q1（4択）**
<質問文>
- A) …
- B) …
- C) …
- D) …

**Q2（記述）**
<質問文>

---

## 📗 振り返りトピック

<!-- topic_key: learning/hybrid-connectivity.md#vpn-expressroute -->
### ハイブリッド接続

**💡 要点リマインド**
- ポイント1 …
- ポイント2 …

**Q1（4択）**
<質問文>
- A) …
- B) …
- C) …
- D) …

**Q2（記述）**
<質問文>

---

## 📝 クイズ結果

_（ユーザーが回答後に自動追記されるセクション — 3.11 参照）_
```

- 1回の実行で **1トピックのみ** 出題する（Q1 + Q2 = 2問）。📘学習中と📗振り返りは `run_count_b` の偶奇で交互に出題される。
- 出題情報は `state.json` の `pending_quizzes` にトピックキーとパターンのみ登録する（3.12 参照）。正解キー・模範解答はアプリ側に保持せず、採点時に Copilot SDK が元資料を参照して判定する（3.11 参照）。

### 3.5 デスクトップ通知

- 結果ファイルが出力されたことをクライアントデスクトップアプリ上でユーザーに提示する。
- **すべて1つの Python プロセス内で動作する**。`pystray` と `winotify` は同一プロセス内で役割を分担し、プロセス間通信は発生しない。
  - `pystray` — アプリの**骨格**。タスクトレイにアイコンを常駐させ、右クリックメニュー（設定 / 手動実行 / 終了）を提供する。アプリのメインループとして動作し続ける。
  - `winotify` — 通知の**部品**。メイン処理完了時に呼び出され、Windows ネイティブのトースト通知を1回表示する。通知クリック時のコールバックにより、アプリ内簡易ビューア（3.6）を起動する。

#### 通知の種類

| 通知 | タイミング | 内容 |
|---|---|---|
| **処理中通知** (`notify_processing`) | 機能 A/B の実行開始時 | 「⬳ 最新情報を取得中…」「⬳ 復習・クイズを生成中…」 |
| **完了通知** (`notify_briefing`) | ブリーフィング出力後 | ファイル名を表示、クリックでビューア起動 |
| **エラー通知** (`notify_error`) | SDK 呼び出しの全リトライ失敗時 | 「❌ 最新情報 (A) 実行エラー」 + エラー概要 + ログ確認案内 |
| **警告通知** (`notify_warning`) | フォルダ不存在、config 復旧等 | 警告内容を表示 |
| **WorkIQ セットアップ通知** | WorkIQ 未設定時（5回に1回） | セットアップダイアログを開く |

#### 処理中インジケーター

機能 A/B の実行中は、トースト通知に加えて**トレイアイコンの色とツールチップ**で処理状態を視覚的に示す:

| 状態 | アイコン色 | ツールチップ |
|---|---|---|
| 通常 | 🟦 青（`#0078D4`） | 「パーソナル AI デイリーブリーフィング Agent」 |
| 処理中 | 🟧 オレンジ（`#FF8C00`） | 「⬳ 最新情報 (A) 生成中…」または「⬳ 復習・クイズ (B) 生成中…」 |

- 処理開始時に `_set_tray_processing(feature)` でアイコン・ツールチップを更新し、処理完了（成功/失敗問わず）後に `_set_tray_normal()` で復帰する。
- アイコン画像は `assets/icon_normal.png` / `assets/icon_processing.png` を使用。ファイルがない場合は単色のフォールバック。

#### 動作の流れ

  1. `pystray` がメインループとしてトレイに常駐（アプリ起動中ずっと動作）
  2. APScheduler（またはメニューからの手動実行）がメイン処理を起動
  3. トレイアイコンをオレンジに切り替え + 処理中トーストを表示
  4. メイン処理完了後、トレイアイコンをブルーに復帰 + 完了通知を1回表示
  5. ユーザーが通知をクリック → アプリ内ビューアが開く
  6. 全リトライ失敗時はエラー通知を表示し、ログ確認を促す

### 3.6 MD プレビューア（アプリ内簡易ビューア）

- 通知クリック時に、出力された MD ファイルをレンダリング済みの見やすい状態で表示する。
- `tkinter` ウィンドウ内に **`tkinterweb`**（`tkhtml` ベースの HTML/CSS レンダリングエンジン）を組み込む。
- MD → HTML 変換には **`markdown2`** ライブラリを使用する（extras: `fenced-code-blocks`, `tables`, `code-friendly` 等）。
- **HTML ファイルは生成しない**。変換した HTML 文字列を直接ウィジェットに渡してレンダリングする（一時ファイル不要）。
- CSS スタイルを適用し、見出し・リスト・コードブロック等を整形して表示する。システムのダークモードを自動検出し（Windows レジストリの `AppsUseLightTheme` を参照）、ライト/ダークテーマを切り替える。
- ウィンドウ内で「ファイルを開く」「フォルダを開く」ボタンも配置し、外部エディタやエクスプローラーでの操作も可能とする。
- **クイズ回答機能**（3.11 と連携）:
  - `tkinterweb` は JavaScript を実行できないため、クイズ回答 UI は **ネイティブ tkinter ウィジェット** で実装する（HTML フォームではなく `Radiobutton` / `Text` / `Button` を使用）。
  - ビューアが `briefing_quiz_*.md` を検出すると、ウィンドウ下部に**固定高さのスクロール可能なクイズパネル**を表示する:
    - Q1（4択）: `Radiobutton` で選択
    - Q2（記述）: `Text` ウィジェットに記述
    - 「まとめて採点する」`Button` で採点を開始
  - 採点はバックグラウンドスレッドで Copilot SDK を呼び出し、結果をパネル上に動的表示する。
  - ローカル HTTP サーバーは不要（ネイティブ UI で完結するため）。

### 3.7 設定メニュー（GUI）

- システムトレイアイコンの右クリックメニューに「設定」項目を設ける。
- 設定メニューから以下を変更可能とする:
  - **実行スケジュール**（機能ごとに独立設定）
    - 「**機能 A: 最新情報の取得**」セクションと「**機能 B: 復習・クイズ**」セクションに分けて表示
    - 各機能ごとに:
      - **曜日選択**: 月〜日のチェックボックス（複数選択可）+ 「平日のみ」「毎日」ショートカットボタン
      - **時刻選択**: 時刻リスト（時単位）に「追加」「削除」で複数指定可
      - **プレビュー表示**: 「次回実行: 月曜 12:00」のように次の実行予定を表示
  - **読み込み対象フォルダ**（複数指定可、フォルダ選択ダイアログで追加・削除・変更）
  - **通知 ON/OFF**（トースト通知の有効/無効切り替え）
- 変更内容は `config.yaml` に書き込み、永続化する。
- スケジュールの変更は APScheduler に即時反映（対応するジョブのリスケジュール）する。
- GUI ウィンドウは軽量なダイアログ（候補: `tkinter` のシンプルダイアログ）で実装する。

### 3.8 起動時前提チェック（セットアップウィザード）

- アプリ起動時に、動作に必要な前提条件を自動チェックする。条件未達の場合はガイド付き GUI でユーザーを案内する。
- **チェック項目**:
  1. **GitHub CLI (`gh`) のインストール確認**: `gh --version` を実行
     - 未インストールの場合: ダイアログで「GitHub CLI が必要です」と表示。「ダウンロードページを開く」ボタンで `https://cli.github.com` をブラウザで開く。または `winget install GitHub.cli` をワンクリックで実行するボタンも提供
  2. **GitHub 認証状態の確認**: `gh auth status` を実行
     - 未ログインの場合: 「GitHub にログインしてください」ダイアログを表示。「ログイン」ボタンで `gh auth login --web` を実行（ブラウザが開き、ユーザーは GitHub 上で「Authorize」を押すだけ）
  3. **Copilot ライセンスの確認**: GitHub CLI および GitHub 認証のチェックが両方 OK の場合のみ、ウィザード内で一時的に Copilot クライアントを起動し、SDK 接続テストを実行する。
     - GitHub CLI または認証が未完了の場合: ライセンスチェックはスキップし「GitHub 認証を先に完了してください」と表示
     - ライセンス未割当の場合: 「Copilot ライセンスが必要です。管理者にお問い合わせください」と表示
     - 一時クライアントはチェック完了後に即座に停止する
  4. **読み込み対象フォルダの確認**: `config.yaml` の `input_folders` が空でないことを確認
     - 未設定の場合: 「読み込み対象フォルダを指定してください」と表示。フォルダ選択ダイアログを開き、選択結果を `config.yaml` に書き込む
- **すべてのチェックをパスした場合のみ、通常起動（トレイ常駐 + スケジューラ開始）に進む**。
- チェック結果はダイアログ内にステータス一覧（✅ / ❌）で表示する。
- **ウィザードの「続行」ボタンの動作**:
  - すべてのチェックをパスしている場合: ウィザードを閉じて通常起動に進む。
  - 未達項目がある場合: ウィザードを閉じず、未達項目を警告メッセージボックスで表示する（「以下の項目が未完了です: …」）。ユーザーは対処後に「再チェック」で状態を更新できる。
  - アプリを終了するのは「終了」ボタンを押した場合のみとする。

### 3.9 エラーハンドリング・リトライ

- **ハイブリッド方式**を採用。エラーを「致命的 / 警告 / 軽微」の3段階に分類し、それぞれ異なる対応をとる。

#### エラー分類と対応

| レベル | 対応 | 通知 | 処理 |
|---|---|---|---|
| **致命的** | トースト通知 + 処理中断 | ✅ | 停止 |
| **警告** | トースト通知 + 処理続行 | ✅ | 続行 |
| **軽微** | ログのみ | — | 続行 |

#### エラー分類詳細

| エラー種別 | レベル | 具体的な対応 |
|---|---|---|
| Copilot SDK タイムアウト | 警告 | リトライ後、失敗すれば次回スケジュールに持ち越し |
| Copilot SDK レート制限 | 警告 | 指数バックオフでリトライ後、持ち越し |
| Copilot SDK 内部エラー | 警告 | リトライ後、エラー通知を表示 |

> **適用範囲**: 上記 3 件の SDK エラー対応は、**ブリーフィング生成時の SDK 呼び出し**および**クイズ採点時の SDK 呼び出し**のいずれにも共通で適用する。
> 採点時の全リトライ失敗時は、ビューア上に「採点に失敗しました。あとで再度お試しください」と表示し、`pending_quizzes` は削除せず残す（ユーザーが再回答可能）。

| 認証切れ（`gh` トークン期限切れ） | 致命的 | 「再ログインが必要です」と通知。トレイメニューに「再認証」ボタンを表示 |
| フォルダ不存在 | 警告 | 該当フォルダをスキップし、トーストで警告 |
| ファイル読み取り権限なし / ロック | 軽微 | 該当ファイルをスキップして続行、ログに記録 |
| エンコーディングエラー（非 UTF-8） | 軽微 | 該当ファイルをスキップして続行、ログに記録 |
| 出力書き込み失敗 | 致命的 | エラー通知を表示。リトライ不要（状態が変わらないため） |
| config.yaml パースエラー / 項目欠落 | 警告 | `.bak` からの復元を試行。失敗時はデフォルト値にフォールバックし、トーストで警告 |
| state.json パースエラー / 破損 | 警告 | `.bak` からの復元を試行。失敗時は初期状態にリセットし、トーストで警告 |
| winotify 通知失敗 | 軽微 | ログに記録。メイン処理の成否には影響させない（best-effort） |
| tkinter ビューア表示失敗 | 軽微 | フォールバックとして OS のデフォルトエディタで MD を直接開く |

#### リトライ方針

| 項目 | 内容 |
|---|---|
| リトライ対象 | **すべての Copilot SDK 呼び出し**（ブリーフィング生成・クイズ採点共通。一過性のネットワーク/サーバー障害が想定されるため） |
| リトライ回数 | 最大 **3回** |
| リトライ間隔 | **指数バックオフ**（5秒 → 15秒 → 45秒） |
| リトライ対象外 | ファイル I/O エラー、config エラー、認証切れ（状態が変わらないため） |
| 全リトライ失敗時 | エラー通知を表示し、次回スケジュール実行に持ち越し。アプリ自体は停止しない |

#### ファイル書き込み安全性（共通ルール）

アプリが管理するファイルへの書き込みは、以下の共通ルールで破損を防止する。

##### アトミック書き込み（write-then-rename）

すべてのファイル書き込みは**一時ファイル経由のリネーム**で行い、書き込み途中の破損を防止する。

```
1. <ファイル名>.tmp に新しい内容を書き込む
2. fsync でディスクにフラッシュ
3. <ファイル名>.tmp → <ファイル名> にリネーム（OS レベルでアトミック）
```

| 対象ファイル | 適用 |
|---|---|
| `state.json` | ✅ |
| `config.yaml` | ✅ |
| `briefing_*.md`（新規生成・クイズ結果追記） | ✅ |
| `app.log` | —（`RotatingFileHandler` に委任） |

##### バックアップ（.bak 保持）

書き込み成功のたびに、直前のファイルを `.bak` として 1 世代保持する。

| 対象ファイル | 適用 | 理由 |
|---|---|---|
| `state.json` → `state.json.bak` | ✅ | クイズ履歴・間隔反復レベルは復元不可能な蓄積データ |
| `config.yaml` → `config.yaml.bak` | ✅ | ユーザーが手動で再入力する手間を回避 |
| `briefing_*.md` | — | write-once（追記はあるが蓄積データではない） |

##### 読み込み時フォールバック

| ファイル | フォールバック手順 |
|---|---|
| `state.json` | ① 本体読み込み → ② 失敗時 `.bak` から復元 → ③ 失敗時 初期状態にリセット。いずれの場合もトーストで「状態ファイルを復旧しました」と警告 |
| `config.yaml` | ① 本体読み込み → ② 失敗時 `.bak` から復元 → ③ 失敗時 デフォルト値で再生成。いずれの場合もトーストで警告 |

### 3.10 ログ出力

- Python 標準ライブラリの **`logging`** モジュールを使用する。
- **出力先**: アプリディレクトリ直下の `logs/` フォルダにログファイルを出力する。
  - 例: `ghcpsdknotify/logs/app.log`
  - `logs/` フォルダはアプリ初回起動時に自動作成する。
- **ローテーション**: **サイズベース**（`RotatingFileHandler`）。
  - 1ファイルあたり最大 **5 MB**、世代数 **5**（`app.log` + `app.log.1` 〜 `app.log.5`）。
  - 最大ディスク使用量: 約 30 MB。
- **ログレベル**: デフォルトは **INFO**。`config.yaml` の `log_level` で変更可能（`DEBUG` / `INFO` / `WARNING` / `ERROR`）。
- **フォーマット**: `%(asctime)s [%(levelname)s] %(name)s - %(message)s`
- **トレイメニュー連携**: システムトレイの右クリックメニューに「**ログを開く**」項目を追加。クリックで `logs/app.log` を OS のデフォルトテキストエディタで開く。
- コンソール（stdout）への出力は行わない（GUI アプリのためコンソールが存在しない前提）。

### 3.11 クイズ回答・採点（ビューア内インタラクション）

ブリーフィング内のクイズに対して、ユーザーが **ビューア上で直接回答** し、採点結果を `state.json` と MD ファイルに反映する仕組み。

#### 方式: ネイティブ tkinter ウィジェット

- `tkinterweb` は JavaScript を実行できないため、クイズの回答 UI はネイティブ tkinter ウィジェット（`Radiobutton` / `Text` / `Button`）で実装する。
- ローカル HTTP サーバーは不要。アプリ単体で完結する。
- **VS Code 拡張や外部ツールは不要**。

#### クイズ回答フロー

```
[ブリーフィング生成 → MD 出力（問題のみ、正解・模範解答なし）]
       ↓
[通知クリック → ビューア起動]
       ↓
[ビューアでブリーフィング表示 + ネイティブ tkinter クイズパネル表示]
       ↓
  Q1（4択）: Radiobutton で選択
  Q2（記述）: Text ウィジェットに記入
       ↓
  「まとめて採点する」Button
       → バックグラウンドスレッドで Copilot SDK に採点リクエスト（Q1 + Q2 一括）
       → 採点結果をパネル上に動的表示
       ↓
[state.json の quiz_history を更新]
[ブリーフィング MD に「📝 クイズ結果」セクションを追記]
```

#### 採点方式（Q1 + Q2 一括・Copilot SDK 呼び出し）

- ブリーフィング生成時には**問題のみ**を出力する。正解キー・解説・模範解答は LLM に出力させない。
- ユーザーが Q1・Q2 に回答後、**1トピックあたり 1回の SDK 呼び出し** で Q1 と Q2 を一括採点する。
- 採点 SDK 呼び出し時には、**元のソース資料（対象 MD ファイルの内容）** もコンテキストに含め、LLM が問題文・ソース資料・ユーザー回答を総合的に評価する。
- 1回の実行で1トピックのみ出題するため、採点 SDK 呼び出しは **1回**。

##### 採点プロンプト（Copilot SDK 呼び出し）

```
以下のクイズの採点を行ってください。
ソース資料と問題文に基づいて、ユーザーの回答を評価してください。

## ソース資料
{source_content}

## Q1（4択）
### 問題
{q1_question_text}
### ユーザーの選択
{q1_user_choice}

## Q2（記述）
### 問題
{q2_question_text}
### ユーザーの回答
{q2_user_answer}

## 採点基準
- Q1: 正解/不正解を判定し、正解の選択肢と解説を付けてください。
- Q2:
  - good: 核心的なポイントを正しく説明できている
  - partial: 方向性は合っているが重要な要素が欠けている
  - poor: 根本的に誤っている、または回答になっていない

## 出力形式（JSON のみ出力）
{
  "q1_correct": true,
  "q1_correct_answer": "B",
  "q1_explanation": "解説文…",
  "q2_evaluation": "good|partial|poor",
  "q2_feedback": "フィードバックコメント"
}
```

- **変数の説明**:
  - `{source_content}`: 出題対象の MD ファイル内容（トピックの元資料）
  - `{q1_question_text}`: ブリーフィング MD から抽出した Q1 問題文+選択肢
  - `{q1_user_choice}`: ユーザーが選択した A/B/C/D
  - `{q2_question_text}`: ブリーフィング MD から抽出した Q2 問題文
  - `{q2_user_answer}`: ユーザーが入力した回答テキスト

#### 未回答の扱い

- **未回答は不正解として扱う**。
- 各ブリーフィング生成時に `state.json` の `pending_quizzes` を確認し、前回以前の未回答クイズがあれば **自動的に不正解として記録** する（Q1: 不正解、Q2: `poor`）。
- 具体的には:
  - B ジョブ実行時、ファイル選定（ステップ 4）の前にステップ 3 で `pending_quizzes` をチェック
  - 回答済みのクイズは `pending_quizzes` から削除済み（回答時に即削除）
  - 残存しているクイズ ＝ 未回答 → 不正解として `quiz_history` に記録し、間隔反復レベルを降格
  - 不正解結果は **出題元の `briefing_quiz_*.md`**（`pending_quizzes[].briefing_file` で特定）に追記
  - 処理後、`pending_quizzes` をクリア
  - A ジョブ時はスキップし、次回 B ジョブ実行時にまとめて処理する
- ユーザーがビューアを開かずにクイズを閲覧しなかった場合も同様に不正解扱いとなる。

#### MD への結果追記

ユーザーが回答するたびに、ブリーフィング MD の末尾に結果セクションを追記する:

```markdown
## 📝 クイズ結果（2026-02-22 09:15）

### 📘 Azure Functions ホスティングプラン
- Q1（4択）: ✅ 正解
- Q2（記述）: 🟡 partial — 「Consumption のコスト面は正しいが、
  Premium の VNET 統合について触れられていません」
- 次回出題: 2026-02-29（Level 2 → 据え置き）

### 📗 ハイブリッド接続
- Q1（4択）: ❌ 不正解（正解: B）
- Q2（記述）: ✅ good — 「判断基準を的確に説明できています」
- 次回出題: 2026-02-23（Level 2 → Level 0 に降格）
```

未回答で自動処理された場合は以下のように記録:

```markdown
## 📝 クイズ結果（自動処理: 未回答）

### 📘 Azure Functions ホスティングプラン
- Q1（4択）: ⬜ 未回答（不正解扱い）
- Q2（記述）: ⬜ 未回答（poor 扱い）
- 次回出題: 2026-02-23（Level 2 → Level 0 に降格）
```

### 3.12 間隔反復（Spaced Repetition）

クイズの回答結果に基づき、**トピックごとの出題間隔を動的に調整** する仕組み。SM-2 アルゴリズムを簡略化したレベル制で管理する。

#### state.json 拡張（quiz_history + pending_quizzes）

```json
{
  "run_count_a": 25,
  "run_count_b": 17,
  "last_run_at": "2026-02-22T08:00:00",
  "output_folder_path": "C:\\Users\\user\\docs\\_briefings",
  "random_pick_history": [],
  "pending_quizzes": [
    {
      "briefing_file": "briefing_quiz_2026-02-22_080000.md",
      "topic_key": "learning/azure-functions.md#hosting-plans",
      "pattern": "learning",
      "created_at": "2026-02-22T08:00:00"
    }
  ],
  "quiz_history": {
    "learning/azure-functions.md#hosting-plans": {
      "last_quizzed_at": "2026-02-20",
      "interval_days": 7,
      "level": 2,
      "next_quiz_at": "2026-02-27",
      "results": [
        {
          "date": "2026-02-15",
          "q1_correct": true,
          "q2_evaluation": "good",
          "pattern": "learning"
        },
        {
          "date": "2026-02-20",
          "q1_correct": false,
          "q2_evaluation": "partial",
          "pattern": "review"
        }
      ]
    }
  }
}
```

- **`topic_key`**: `{ファイルの相対パス}#{セクション識別子}` 形式。LLM がクイズ生成時にブリーフィング MD 内の `<!-- topic_key: ... -->` HTML コメントとして出力し、アプリが MD パース時に抽出して `pending_quizzes` に登録する。採点時はこの `topic_key` のファイルパス部分から元の MD ファイルを特定し、`{source_content}` として採点プロンプトに渡す。
- **`pending_quizzes`**: 出題済み・未回答のクイズ一覧。回答時に即削除、次回ブリーフィング生成時に残存分を不正解処理。
- **`quiz_history`**: トピックごとの回答履歴と間隔反復レベル。

#### 反復間隔アルゴリズム（レベル制）

| Level | 間隔 | 昇格条件 | 降格条件 |
|---|---|---|---|
| 0 | 1日 | Q1 正解 かつ Q2 good | — |
| 1 | 3日 | Q1 正解 かつ Q2 good | Q1 不正解 or Q2 poor → Level 0 |
| 2 | 7日 | Q1 正解 かつ Q2 good | Q1 不正解 or Q2 poor → Level 0 |
| 3 | 14日 | Q1 正解 かつ Q2 good | Q1 不正解 or Q2 poor → Level 0 |
| 4 | 30日 | Q1 正解 かつ Q2 good | Q1 不正解 or Q2 poor → Level 0 |
| 5 | 60日（上限） | — | Q1 不正解 or Q2 poor → Level 0 |

- **昇格**: Q1 正解 **かつ** Q2 `good` の場合、Level +1（最大 5）。
- **降格**: Q1 不正解 **または** Q2 `poor` の場合、Level 0 にリセット。
- **据え置き**: Q2 が `partial` の場合、Level を変更しない（昇格も降格もしない）。
- **未回答**: Q1 不正解 + Q2 `poor` として処理 → Level 0 にリセット。

#### 出題優先度への反映

- ブリーフィング生成時、`quiz_history` の `next_quiz_at` を参照する。
- `next_quiz_at <= today` のトピック（出題期限到来）を **優先的にクイズ対象** として選出する。
- 機能 B のユーザープロンプトに `{quiz_schedule_info}` として以下の情報を動的に埋め込む（3.3 参照）:
  - 出題期限が到来しているトピック一覧
  - 各トピックの現在の Level と過去の正答状況
- これにより、LLM は忘却リスクの高いトピックを優先的に出題できる。
- 期限到来トピックがない場合は、通常通りファイルの最終更新日に基づいて出題する。

---

## 4. アーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│  クライアントデスクトップアプリ (Python / システムトレイ常駐)  │
│                                                         │
│  ┌────────────┐  ┌────────────┐  ┌───────────────┐  │
│  │ スケジューラ │  │ 通知UI     │  │ 設定メニュー   │  │
│  │(APScheduler)│  │ (pystray   │  │ (tkinter)      │  │
│  │ job_a/job_b │  │  +winotify)│  │  → config.yaml │  │
│  └─────┬──────┘  └─────▲──────┘  └───────────────┘  │
│        │               │                              │
│        ▼               │                              │
│  ┌──────────────────────────────────────────┐  │
│  │ メイン処理                                    │  │
│  │                                              │  │
│  │  1. フォルダ走査・MD 読み込み                  │  │
│  │  2. ファイル選定（関心度スコアリング）        │  │
│  │  3. Copilot SDK 呼び出し (生成)              │  │
│  │  4. MD ファイル出力                          │  │
│  │  5. state.json 更新 (pending_quizzes 等)    │  │
│  │  6. 通知トリガー                            │  │
│  └─────────┬────────────────────────────────┘  │
│            │                                          │
│            │  ┌────────────────────────────────┐  │
│            │  │ ビューア + クイズ回答系             │  │
│            │  │                                │  │
│            │  │  ┌───────────────┐              │  │
│            │  │  │ MD プレビューア│              │  │
│            │  │  │(tkinterweb)   │◄── 通知クリック│  │
│            │  │  └───────┬───────┘              │  │
│            │  │          │ フォーム送信           │  │
│            │  │          ▼                        │  │
│            │  │  ┌───────────────┐              │  │
│            │  │  │ローカルHTTP    │              │  │
│            │  │  │サーバー       │              │  │
│            │  │  │(127.0.0.1)   │──→ SDK採点  │  │
│            │  │  └───────┬───────┘              │  │
│            │  │          │                        │  │
│            │  │          ▼                        │  │
│            │  │  state.json 更新               │  │
│            │  │  (採点結果・quiz_history・     │  │
│            │  │   間隔反復レベル)              │  │
│            │  └────────────────────────────────┘  │
│            │                                          │
└────────────┼──────────────────────────────────────────┘
             │
             ▼
  ┌──────────────────────┐
  │ GitHub Copilot SDK   │
  │ (LLM推論 + Tools)    │
  │                      │
  │  - web_search (Bing)  │
  │  - WorkIQ MCP (社内)  │
  │  ※mcp_servers で登録  │
  └──────────────────────┘
             │
             ▼
  ┌──────────────────────┐
  │ 出力フォルダ          │
  │  briefing_news_*.md  │
  │  briefing_quiz_*.md  │
  └──────────────────────┘
```

---

## 5. 設定ファイル（config.yaml 案）

```yaml
# 読み込み対象フォルダ（親フォルダを指定。配下を再帰的に走査）
# 初回起動時に設定メニューから GUI で指定する
input_folders: []

# 出力先フォルダ名（最初の input_folder 直下に自動作成）
output_folder_name: _briefings

# 実行スケジュール（機能ごとに独立設定、cron 形式 — APScheduler CronTrigger 準拠）
schedule:
  feature_a:                     # 機能 A: 最新情報の取得
    - day_of_week: mon-fri       # 曜日（mon-sun, カンマ区切り or ハイフン範囲）
      hour: "9"                  # 時刻（カンマ区切りで複数指定可）
  feature_b:                     # 機能 B: 復習・クイズ
    - day_of_week: mon,wed,fri
      hour: "8"

# 対象ファイル拡張子
target_extensions:
  - .md

# GitHub Copilot SDK 設定
copilot_sdk:
  model: "claude-sonnet-4.6"    # 使用する LLM モデル名（例: gpt-5, claude-sonnet-4.5）
  system_message_mode: "replace" # "replace"（完全置換）or "append"（SDK ガードレール維持+追記）
  reasoning_effort: "medium"     # 推論の深さ: low / medium / high / xhigh
  max_context_tokens: 100000    # コンテキストに含めるファイル内容の最大トークン数目安
  sdk_timeout: 180               # ブリーフィング生成の SDK 呼び出し1回あたりのタイムアウト（秒）
  # 以下はハードコード（config に公開しない）:
  # streaming: false              — バッチ処理のため不要。send_and_wait() を使用
  # infinite_sessions: false      — 各ブリーフィングは独立した1回限りのセッション

# WorkIQ MCP サーバー設定
workiq_mcp:
  enabled: false                # true にすると社内検索が有効になる（stdio MCP）
  suppress_setup_prompt: false  # true にすると未設定時のセットアップ案内通知を非表示

# 通知設定
notification:
  enabled: true
  open_file_on_click: true

# ファイル選定設定
file_selection:
  max_files: 20                # LLM に渡す最大ファイル数
  discovery_interval: 5        # ディスカバリー回の間隔（N回に1回）

# クイズ・間隔反復設定
quiz:
  quiz_scoring_timeout: 30         # クイズ採点の Copilot SDK 呼び出しタイムアウト（秒）
  spaced_repetition:
    enabled: true                  # 間隔反復機能の ON/OFF
    max_level: 5                   # 最大レベル（Level 5 = 60日間隔）
    intervals: [1, 3, 7, 14, 30, 60]  # 各レベルの間隔（日数）

# ログ設定
log_level: INFO   # DEBUG / INFO / WARNING / ERROR
```

---

## 6. 処理フロー

```
[起動] → [前提チェック (gh CLI / 認証 / Copilot ライセンス)]
                │  ❌ 未達の場合 → [セットアップウィザード GUI で案内]
                │  ✅ 全パス
                ▼
        [config.yaml 読み込み] → [APScheduler 開始 & システムトレイ常駐]
                │                           │
                │    [設定メニューからスケジュール変更] → [config.yaml 書き込み]
                │              → [APScheduler リスケジュール]
                │
                ▼ (定期 or 手動トリガー)
        [トリガー判定: 実行対象機能を決定]
                │  job_a 発火 → A のみ / job_b 発火 → B のみ
                │  同時刻重複 → A 先行、B を3分後に自動遅延
                │  手動 → 選択に従う（A+B選択時も A→B 順次実行）
                ▼
        [1. 指定フォルダ再帰走査]
                │
                ▼
        [2. MD ファイル読み込み & メタデータ抽出]
                │
                ▼
        [3. 未回答クイズの自動不正解処理（B ジョブ時のみ）]
                │  pending_quizzes の残存分 → 不正解として quiz_history に記録
                │  → 出題元の briefing_quiz_*.md に「📝 クイズ結果（自動処理: 未回答）」追記
                │  → 間隔反復レベル降格
                │  ※ A ジョブ時はスキップ（次回 B ジョブ時にまとめて処理）
                ▼
        [4. 関心度スコアリング & ファイル選定]
                │  通常回: 上位17+ランダム3
                │  ディスカバリー回: 上位5+ランダム15
                ▼
        [5. コンテキスト構築 → Copilot SDK 呼び出し]
                │  ⏵ 実行対象機能に応じたプロンプトを動的選択:
                │    A: 最新情報専用プロンプト
                │    B: 復習・クイズ専用プロンプト
                │  ⏵ B の場合、{quiz_schedule_info} はステップ3で更新済みの
                │    quiz_history を反映（最新の next_quiz_at を参照）
                ▼
        [6. Tool Calling: ネット/社内情報取得（A の場合）]
                │
                ▼
        [7. LLM 推論: ブリーフィング生成]
                │
                ▼
        [8. MD ファイル出力 (入力フォルダ直下の _briefings/ へ)]
                ▼
        [9. state.json 更新 (run_count_a/b, ランダム履歴, pending_quizzes 登録)]
                │
                ▼
        [10. デスクトップ通知表示]
                │
                ▼ (ユーザー操作)
        [11. 通知クリック → ビューア起動（ネイティブ tkinter クイズパネル付き）]
                │
                ▼
        [12. クイズ回答 → 採点 → 結果表示]
                │  Q1+Q2: Copilot SDK で一括採点（1トピック1回の SDK 呼び出し）
                ▼
        [13. state.json 更新 (quiz_history, pending_quizzes 削除)]
                │  + ブリーフィング MD に「📝 クイズ結果」追記
                │  + 間隔反復レベル更新
                ▼
        [14. ビューア閉じる]
```

---

## 7. ディレクトリ構成（案）

```
ghcpsdknotify/
├── app/
│   ├── __init__.py
│   ├── main.py              # エントリーポイント（トレイ常駐 + スケジューラ起動）
│   ├── utils.py             # 共通ユーティリティ（アトミック書き込み等）
│   ├── scheduler.py         # 定期実行制御（APScheduler ベース）
│   ├── folder_scanner.py    # フォルダ走査・MD 読み込み
│   ├── copilot_client.py    # GitHub Copilot SDK 連携
│   ├── output_writer.py     # MD ファイル出力
│   ├── viewer.py            # MD プレビューア（tkinterweb + ネイティブ tkinter クイズパネル）
│   ├── notifier.py          # デスクトップ通知（完了/処理中/エラー/警告/WorkIQセットアップ）
│   ├── settings_ui.py       # 設定メニュー GUI（tkinter ダイアログ）
│   ├── setup_wizard.py      # 起動時前提チェック GUI（3.8）
│   ├── logger.py            # ログ設定（RotatingFileHandler）
│   ├── file_selector.py     # 関心度スコアリング・ファイル選定（ディスカバリー機構含む）
│   ├── state_manager.py     # state.json I/O（アトミック書き込み・.bak・フォールバック）
│   ├── quiz_server.py       # （未使用: ネイティブ tkinter に置換済み）
│   ├── quiz_scorer.py       # Q1+Q2 一括採点（Copilot SDK 呼び出し）
│   ├── spaced_repetition.py # 間隔反復アルゴリズム・quiz_history 管理
│   └── config.py            # 設定読み込み・書き込み（config.yaml I/O）
├── config.yaml              # 設定ファイル
├── state.json               # 内部状態（実行カウンタ・ランダム履歴・クイズ履歴・間隔反復等）
├── logs/                    # ログ出力先（自動作成）
│   └── app.log
├── pyproject.toml           # 依存関係管理（uv）
└── README.md
```

> **出力先**: ユーザーが指定した最初の入力フォルダ直下に `_briefings/` が自動作成され、そこにブリーフィング MD が出力される。

---

## 8. 未決定事項（TBD）

| # | 項目 | 備考 |
|---|---|---|
| 1 | ~~Copilot SDK に渡すプロンプトの具体的な内容~~ | **決定済**: 2機能構成 — (A) 最新情報取得（Web + 社内を統合、LLM 自律ルーティング） (B) 復習・クイズ生成。システムプロンプト・ユーザープロンプト・Tool 定義を仕様書 3.3 に記載 |
| 2 | ~~ネット情報取得の具体的なソース・API~~ | **決定済**: Copilot SDK 側の組み込み Web 検索に委譲（アプリ側では実装しない） |
| 3 | ~~社内情報取得の対象と接続方式~~ | **決定済**: WorkIQ MCP サーバーを使用（stdio 方式、`npx -y @microsoft/workiq mcp` で自動起動）。`config.yaml` の `workiq_mcp.enabled` で有効/無効を管理し、SDK の `create_session(mcp_servers=...)` で登録 |
| 4 | ~~デスクトップ UI フレームワークの最終選定~~ | **決定済**: `pystray`（トレイ） + `winotify`（通知） |
| 5 | ~~Python スケジューラ vs OS スケジューラの最終決定~~ | **決定済**: `APScheduler` をアプリ内蔵で使用 |
| 6 | ~~認証方式（Copilot SDK / 社内リソース）~~ | **決定済**: アプリ側にトークン・キーは保存しない。Copilot SDK は `gh` CLI の既存認証を利用。WorkIQ MCP はサーバー側で Entra ID SSO を処理 |
| 7 | ~~エラーハンドリング・リトライ方針~~ | **決定済**: ハイブリッド方式（致命的/警告/軽微の3段階）。Copilot SDK のみ指数バックオフで最大3回リトライ |
| 8 | ~~ログ出力方式~~ | **決定済**: Python 標準 `logging` + `RotatingFileHandler`（5MB×5世代）。アプリディレクトリの `logs/` に出力。レベルは `config.yaml` で設定可能 |

---

## 9. 制約・前提

- **対象 OS は Windows（Windows 10 / 11）のみ**。macOS / Linux はサポート対象外。
- **アプリ側では外部とのネットワーク通信を一切行わない**。Web 検索・社内情報取得などすべての外部通信は GitHub Copilot SDK 側を経由して行う。アプリ自身が直接 HTTP リクエストを発行したり、外部 API キーを管理したりすることはない。
- **アプリ側に認証トークン・API キーは保存しない**。認証は外部の既存セッションに委譲する:
  - Copilot SDK → GitHub CLI (`gh`) の既存認証（OS 資格情報マネージャー経由）
  - WorkIQ MCP → stdio MCP サーバーとして `npx -y @microsoft/workiq mcp` で自動起動。認証はサーバー側で Entra ID (Azure AD) の SSO セッションを利用
  - 前提: `gh` CLI がインストール・`gh auth login` 済み、Copilot ライセンス割当済み、Entra ID で Windows にログイン済みであること
- ローカル実行を前提とし、**アプリ自身が独自に外部へ PII を送信することはない**。ファイル内容を含むすべての外部通信は GitHub Copilot SDK 経由で行われ、Copilot の利用規約・データ保護ポリシーの範囲内で処理される。アプリが直接 HTTP リクエストを発行したり、サードパーティ API にデータを送信することはない。
- **OS のタスクスケジューラには依存しない**。定期実行はアプリプロセス内の `APScheduler` で完結させる。
- GitHub Copilot SDK のライセンス・利用規約に準拠する。
